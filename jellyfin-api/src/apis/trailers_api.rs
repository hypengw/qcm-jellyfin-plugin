/*
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.10.6
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`get_trailers`]
#[derive(Clone, Debug)]
pub struct GetTrailersParams {
    /// The user id supplied as query parameter; this is required when not using an API key.
    pub user_id: Option<String>,
    /// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
    pub max_official_rating: Option<String>,
    /// Optional filter by items with theme songs.
    pub has_theme_song: Option<bool>,
    /// Optional filter by items with theme videos.
    pub has_theme_video: Option<bool>,
    /// Optional filter by items with subtitles.
    pub has_subtitles: Option<bool>,
    /// Optional filter by items with special features.
    pub has_special_feature: Option<bool>,
    /// Optional filter by items with trailers.
    pub has_trailer: Option<bool>,
    /// Optional. Return items that are siblings of a supplied item.
    pub adjacent_to: Option<String>,
    /// Optional filter by parent index number.
    pub parent_index_number: Option<i32>,
    /// Optional filter by items that have or do not have a parental rating.
    pub has_parental_rating: Option<bool>,
    /// Optional filter by items that are HD or not.
    pub is_hd: Option<bool>,
    /// Optional filter by items that are 4K or not.
    pub is4_k: Option<bool>,
    /// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
    pub location_types: Option<Vec<models::LocationType>>,
    /// Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
    pub exclude_location_types: Option<Vec<models::LocationType>>,
    /// Optional filter by items that are missing episodes or not.
    pub is_missing: Option<bool>,
    /// Optional filter by items that are unaired episodes or not.
    pub is_unaired: Option<bool>,
    /// Optional filter by minimum community rating.
    pub min_community_rating: Option<f64>,
    /// Optional filter by minimum critic rating.
    pub min_critic_rating: Option<f64>,
    /// Optional. The minimum premiere date. Format = ISO.
    pub min_premiere_date: Option<String>,
    /// Optional. The minimum last saved date. Format = ISO.
    pub min_date_last_saved: Option<String>,
    /// Optional. The minimum last saved date for the current user. Format = ISO.
    pub min_date_last_saved_for_user: Option<String>,
    /// Optional. The maximum premiere date. Format = ISO.
    pub max_premiere_date: Option<String>,
    /// Optional filter by items that have an overview or not.
    pub has_overview: Option<bool>,
    /// Optional filter by items that have an IMDb id or not.
    pub has_imdb_id: Option<bool>,
    /// Optional filter by items that have a TMDb id or not.
    pub has_tmdb_id: Option<bool>,
    /// Optional filter by items that have a TVDb id or not.
    pub has_tvdb_id: Option<bool>,
    /// Optional filter for live tv movies.
    pub is_movie: Option<bool>,
    /// Optional filter for live tv series.
    pub is_series: Option<bool>,
    /// Optional filter for live tv news.
    pub is_news: Option<bool>,
    /// Optional filter for live tv kids.
    pub is_kids: Option<bool>,
    /// Optional filter for live tv sports.
    pub is_sports: Option<bool>,
    /// Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
    pub exclude_item_ids: Option<Vec<uuid::Uuid>>,
    /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
    pub start_index: Option<i32>,
    /// Optional. The maximum number of records to return.
    pub limit: Option<i32>,
    /// When searching within folders, this determines whether or not the search will be recursive. true/false.
    pub recursive: Option<bool>,
    /// Optional. Filter based on a search term.
    pub search_term: Option<String>,
    /// Sort Order - Ascending, Descending.
    pub sort_order: Option<Vec<models::SortOrder>>,
    /// Specify this to localize the search to a specific item or folder. Omit to use the root.
    pub parent_id: Option<String>,
    /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
    pub fields: Option<Vec<models::ItemFields>>,
    /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
    pub exclude_item_types: Option<Vec<models::BaseItemKind>>,
    /// Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
    pub filters: Option<Vec<models::ItemFilter>>,
    /// Optional filter by items that are marked as favorite, or not.
    pub is_favorite: Option<bool>,
    /// Optional filter by MediaType. Allows multiple, comma delimited.
    pub media_types: Option<Vec<models::MediaType>>,
    /// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
    pub image_types: Option<Vec<models::ImageType>>,
    /// Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
    pub sort_by: Option<Vec<models::ItemSortBy>>,
    /// Optional filter by items that are played, or not.
    pub is_played: Option<bool>,
    /// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
    pub genres: Option<Vec<String>>,
    /// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
    pub official_ratings: Option<Vec<String>>,
    /// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
    pub tags: Option<Vec<String>>,
    /// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
    pub years: Option<Vec<i32>>,
    /// Optional, include user data.
    pub enable_user_data: Option<bool>,
    /// Optional, the max number of images to return, per image type.
    pub image_type_limit: Option<i32>,
    /// Optional. The image types to include in the output.
    pub enable_image_types: Option<Vec<models::ImageType>>,
    /// Optional. If specified, results will be filtered to include only those containing the specified person.
    pub person: Option<String>,
    /// Optional. If specified, results will be filtered to include only those containing the specified person id.
    pub person_ids: Option<Vec<uuid::Uuid>>,
    /// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
    pub person_types: Option<Vec<String>>,
    /// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
    pub studios: Option<Vec<String>>,
    /// Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
    pub artists: Option<Vec<String>>,
    /// Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
    pub exclude_artist_ids: Option<Vec<uuid::Uuid>>,
    /// Optional. If specified, results will be filtered to include only those containing the specified artist id.
    pub artist_ids: Option<Vec<uuid::Uuid>>,
    /// Optional. If specified, results will be filtered to include only those containing the specified album artist id.
    pub album_artist_ids: Option<Vec<uuid::Uuid>>,
    /// Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
    pub contributing_artist_ids: Option<Vec<uuid::Uuid>>,
    /// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
    pub albums: Option<Vec<String>>,
    /// Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
    pub album_ids: Option<Vec<uuid::Uuid>>,
    /// Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
    pub ids: Option<Vec<uuid::Uuid>>,
    /// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
    pub video_types: Option<Vec<models::VideoType>>,
    /// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
    pub min_official_rating: Option<String>,
    /// Optional filter by items that are locked.
    pub is_locked: Option<bool>,
    /// Optional filter by items that are placeholders.
    pub is_place_holder: Option<bool>,
    /// Optional filter by items that have official ratings.
    pub has_official_rating: Option<bool>,
    /// Whether or not to hide items behind their boxsets.
    pub collapse_box_set_items: Option<bool>,
    /// Optional. Filter by the minimum width of the item.
    pub min_width: Option<i32>,
    /// Optional. Filter by the minimum height of the item.
    pub min_height: Option<i32>,
    /// Optional. Filter by the maximum width of the item.
    pub max_width: Option<i32>,
    /// Optional. Filter by the maximum height of the item.
    pub max_height: Option<i32>,
    /// Optional filter by items that are 3D, or not.
    pub is3_d: Option<bool>,
    /// Optional filter by Series Status. Allows multiple, comma delimited.
    pub series_status: Option<Vec<models::SeriesStatus>>,
    /// Optional filter by items whose name is sorted equally or greater than a given input string.
    pub name_starts_with_or_greater: Option<String>,
    /// Optional filter by items whose name is sorted equally than a given input string.
    pub name_starts_with: Option<String>,
    /// Optional filter by items whose name is equally or lesser than a given input string.
    pub name_less_than: Option<String>,
    /// Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
    pub studio_ids: Option<Vec<uuid::Uuid>>,
    /// Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
    pub genre_ids: Option<Vec<uuid::Uuid>>,
    /// Optional. Enable the total record count.
    pub enable_total_record_count: Option<bool>,
    /// Optional, include image information in output.
    pub enable_images: Option<bool>
}


/// struct for typed successes of method [`get_trailers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTrailersSuccess {
    Status200(models::BaseItemDtoQueryResult),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_trailers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTrailersError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}


pub async fn get_trailers(configuration: &configuration::Configuration, params: GetTrailersParams) -> Result<ResponseContent<GetTrailersSuccess>, Error<GetTrailersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;
    let max_official_rating = params.max_official_rating;
    let has_theme_song = params.has_theme_song;
    let has_theme_video = params.has_theme_video;
    let has_subtitles = params.has_subtitles;
    let has_special_feature = params.has_special_feature;
    let has_trailer = params.has_trailer;
    let adjacent_to = params.adjacent_to;
    let parent_index_number = params.parent_index_number;
    let has_parental_rating = params.has_parental_rating;
    let is_hd = params.is_hd;
    let is4_k = params.is4_k;
    let location_types = params.location_types;
    let exclude_location_types = params.exclude_location_types;
    let is_missing = params.is_missing;
    let is_unaired = params.is_unaired;
    let min_community_rating = params.min_community_rating;
    let min_critic_rating = params.min_critic_rating;
    let min_premiere_date = params.min_premiere_date;
    let min_date_last_saved = params.min_date_last_saved;
    let min_date_last_saved_for_user = params.min_date_last_saved_for_user;
    let max_premiere_date = params.max_premiere_date;
    let has_overview = params.has_overview;
    let has_imdb_id = params.has_imdb_id;
    let has_tmdb_id = params.has_tmdb_id;
    let has_tvdb_id = params.has_tvdb_id;
    let is_movie = params.is_movie;
    let is_series = params.is_series;
    let is_news = params.is_news;
    let is_kids = params.is_kids;
    let is_sports = params.is_sports;
    let exclude_item_ids = params.exclude_item_ids;
    let start_index = params.start_index;
    let limit = params.limit;
    let recursive = params.recursive;
    let search_term = params.search_term;
    let sort_order = params.sort_order;
    let parent_id = params.parent_id;
    let fields = params.fields;
    let exclude_item_types = params.exclude_item_types;
    let filters = params.filters;
    let is_favorite = params.is_favorite;
    let media_types = params.media_types;
    let image_types = params.image_types;
    let sort_by = params.sort_by;
    let is_played = params.is_played;
    let genres = params.genres;
    let official_ratings = params.official_ratings;
    let tags = params.tags;
    let years = params.years;
    let enable_user_data = params.enable_user_data;
    let image_type_limit = params.image_type_limit;
    let enable_image_types = params.enable_image_types;
    let person = params.person;
    let person_ids = params.person_ids;
    let person_types = params.person_types;
    let studios = params.studios;
    let artists = params.artists;
    let exclude_artist_ids = params.exclude_artist_ids;
    let artist_ids = params.artist_ids;
    let album_artist_ids = params.album_artist_ids;
    let contributing_artist_ids = params.contributing_artist_ids;
    let albums = params.albums;
    let album_ids = params.album_ids;
    let ids = params.ids;
    let video_types = params.video_types;
    let min_official_rating = params.min_official_rating;
    let is_locked = params.is_locked;
    let is_place_holder = params.is_place_holder;
    let has_official_rating = params.has_official_rating;
    let collapse_box_set_items = params.collapse_box_set_items;
    let min_width = params.min_width;
    let min_height = params.min_height;
    let max_width = params.max_width;
    let max_height = params.max_height;
    let is3_d = params.is3_d;
    let series_status = params.series_status;
    let name_starts_with_or_greater = params.name_starts_with_or_greater;
    let name_starts_with = params.name_starts_with;
    let name_less_than = params.name_less_than;
    let studio_ids = params.studio_ids;
    let genre_ids = params.genre_ids;
    let enable_total_record_count = params.enable_total_record_count;
    let enable_images = params.enable_images;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/Trailers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = user_id {
        local_var_req_builder = local_var_req_builder.query(&[("userId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_official_rating {
        local_var_req_builder = local_var_req_builder.query(&[("maxOfficialRating", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_theme_song {
        local_var_req_builder = local_var_req_builder.query(&[("hasThemeSong", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_theme_video {
        local_var_req_builder = local_var_req_builder.query(&[("hasThemeVideo", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_subtitles {
        local_var_req_builder = local_var_req_builder.query(&[("hasSubtitles", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_special_feature {
        local_var_req_builder = local_var_req_builder.query(&[("hasSpecialFeature", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_trailer {
        local_var_req_builder = local_var_req_builder.query(&[("hasTrailer", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = adjacent_to {
        local_var_req_builder = local_var_req_builder.query(&[("adjacentTo", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = parent_index_number {
        local_var_req_builder = local_var_req_builder.query(&[("parentIndexNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_parental_rating {
        local_var_req_builder = local_var_req_builder.query(&[("hasParentalRating", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_hd {
        local_var_req_builder = local_var_req_builder.query(&[("isHd", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is4_k {
        local_var_req_builder = local_var_req_builder.query(&[("is4K", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location_types {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("locationTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("locationTypes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = exclude_location_types {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("excludeLocationTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("excludeLocationTypes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = is_missing {
        local_var_req_builder = local_var_req_builder.query(&[("isMissing", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_unaired {
        local_var_req_builder = local_var_req_builder.query(&[("isUnaired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_community_rating {
        local_var_req_builder = local_var_req_builder.query(&[("minCommunityRating", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_critic_rating {
        local_var_req_builder = local_var_req_builder.query(&[("minCriticRating", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_premiere_date {
        local_var_req_builder = local_var_req_builder.query(&[("minPremiereDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_date_last_saved {
        local_var_req_builder = local_var_req_builder.query(&[("minDateLastSaved", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_date_last_saved_for_user {
        local_var_req_builder = local_var_req_builder.query(&[("minDateLastSavedForUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_premiere_date {
        local_var_req_builder = local_var_req_builder.query(&[("maxPremiereDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_overview {
        local_var_req_builder = local_var_req_builder.query(&[("hasOverview", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_imdb_id {
        local_var_req_builder = local_var_req_builder.query(&[("hasImdbId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_tmdb_id {
        local_var_req_builder = local_var_req_builder.query(&[("hasTmdbId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_tvdb_id {
        local_var_req_builder = local_var_req_builder.query(&[("hasTvdbId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_movie {
        local_var_req_builder = local_var_req_builder.query(&[("isMovie", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_series {
        local_var_req_builder = local_var_req_builder.query(&[("isSeries", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_news {
        local_var_req_builder = local_var_req_builder.query(&[("isNews", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_kids {
        local_var_req_builder = local_var_req_builder.query(&[("isKids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_sports {
        local_var_req_builder = local_var_req_builder.query(&[("isSports", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_item_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("excludeItemIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("excludeItemIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = start_index {
        local_var_req_builder = local_var_req_builder.query(&[("startIndex", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recursive {
        local_var_req_builder = local_var_req_builder.query(&[("recursive", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = search_term {
        local_var_req_builder = local_var_req_builder.query(&[("searchTerm", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_order {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("sortOrder".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("sortOrder", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = parent_id {
        local_var_req_builder = local_var_req_builder.query(&[("parentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("fields".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("fields", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = exclude_item_types {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("excludeItemTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("excludeItemTypes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = filters {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("filters".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("filters", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = is_favorite {
        local_var_req_builder = local_var_req_builder.query(&[("isFavorite", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = media_types {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("mediaTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("mediaTypes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = image_types {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("imageTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("imageTypes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = sort_by {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("sortBy".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("sortBy", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = is_played {
        local_var_req_builder = local_var_req_builder.query(&[("isPlayed", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = genres {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("genres".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("genres", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = official_ratings {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("officialRatings".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("officialRatings", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = tags {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("tags".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("tags", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = years {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("years".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("years", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = enable_user_data {
        local_var_req_builder = local_var_req_builder.query(&[("enableUserData", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = image_type_limit {
        local_var_req_builder = local_var_req_builder.query(&[("imageTypeLimit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_image_types {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("enableImageTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("enableImageTypes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = person {
        local_var_req_builder = local_var_req_builder.query(&[("person", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = person_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("personIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("personIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = person_types {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("personTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("personTypes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = studios {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("studios".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("studios", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = artists {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("artists".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("artists", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = exclude_artist_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("excludeArtistIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("excludeArtistIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = artist_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("artistIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("artistIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = album_artist_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("albumArtistIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("albumArtistIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = contributing_artist_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("contributingArtistIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("contributingArtistIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = albums {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("albums".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("albums", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = album_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("albumIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("albumIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = video_types {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("videoTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("videoTypes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = min_official_rating {
        local_var_req_builder = local_var_req_builder.query(&[("minOfficialRating", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_locked {
        local_var_req_builder = local_var_req_builder.query(&[("isLocked", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_place_holder {
        local_var_req_builder = local_var_req_builder.query(&[("isPlaceHolder", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_official_rating {
        local_var_req_builder = local_var_req_builder.query(&[("hasOfficialRating", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = collapse_box_set_items {
        local_var_req_builder = local_var_req_builder.query(&[("collapseBoxSetItems", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_width {
        local_var_req_builder = local_var_req_builder.query(&[("minWidth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_height {
        local_var_req_builder = local_var_req_builder.query(&[("minHeight", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_width {
        local_var_req_builder = local_var_req_builder.query(&[("maxWidth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_height {
        local_var_req_builder = local_var_req_builder.query(&[("maxHeight", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is3_d {
        local_var_req_builder = local_var_req_builder.query(&[("is3D", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = series_status {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("seriesStatus".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("seriesStatus", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = name_starts_with_or_greater {
        local_var_req_builder = local_var_req_builder.query(&[("nameStartsWithOrGreater", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name_starts_with {
        local_var_req_builder = local_var_req_builder.query(&[("nameStartsWith", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name_less_than {
        local_var_req_builder = local_var_req_builder.query(&[("nameLessThan", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = studio_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("studioIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("studioIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = genre_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("genreIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("genreIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = enable_total_record_count {
        local_var_req_builder = local_var_req_builder.query(&[("enableTotalRecordCount", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_images {
        local_var_req_builder = local_var_req_builder.query(&[("enableImages", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetTrailersSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetTrailersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

