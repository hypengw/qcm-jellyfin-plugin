/*
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.10.6
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`add_listing_provider`]
#[derive(Clone, Debug)]
pub struct AddListingProviderParams {
    /// Password.
    pub pw: Option<String>,
    /// Validate listings.
    pub validate_listings: Option<bool>,
    /// Validate login.
    pub validate_login: Option<bool>,
    /// New listings info.
    pub listings_provider_info: Option<models::ListingsProviderInfo>
}

/// struct for passing parameters to the method [`add_tuner_host`]
#[derive(Clone, Debug)]
pub struct AddTunerHostParams {
    /// New tuner host.
    pub tuner_host_info: Option<models::TunerHostInfo>
}

/// struct for passing parameters to the method [`cancel_series_timer`]
#[derive(Clone, Debug)]
pub struct CancelSeriesTimerParams {
    /// Timer id.
    pub timer_id: String
}

/// struct for passing parameters to the method [`cancel_timer`]
#[derive(Clone, Debug)]
pub struct CancelTimerParams {
    /// Timer id.
    pub timer_id: String
}

/// struct for passing parameters to the method [`create_series_timer`]
#[derive(Clone, Debug)]
pub struct CreateSeriesTimerParams {
    /// New series timer info.
    pub series_timer_info_dto: Option<models::SeriesTimerInfoDto>
}

/// struct for passing parameters to the method [`create_timer`]
#[derive(Clone, Debug)]
pub struct CreateTimerParams {
    /// New timer info.
    pub timer_info_dto: Option<models::TimerInfoDto>
}

/// struct for passing parameters to the method [`delete_listing_provider`]
#[derive(Clone, Debug)]
pub struct DeleteListingProviderParams {
    /// Listing provider id.
    pub id: Option<String>
}

/// struct for passing parameters to the method [`delete_recording`]
#[derive(Clone, Debug)]
pub struct DeleteRecordingParams {
    /// Recording id.
    pub recording_id: String
}

/// struct for passing parameters to the method [`delete_tuner_host`]
#[derive(Clone, Debug)]
pub struct DeleteTunerHostParams {
    /// Tuner host id.
    pub id: Option<String>
}

/// struct for passing parameters to the method [`discover_tuners`]
#[derive(Clone, Debug)]
pub struct DiscoverTunersParams {
    /// Only discover new tuners.
    pub new_devices_only: Option<bool>
}

/// struct for passing parameters to the method [`discvover_tuners`]
#[derive(Clone, Debug)]
pub struct DiscvoverTunersParams {
    /// Only discover new tuners.
    pub new_devices_only: Option<bool>
}

/// struct for passing parameters to the method [`get_channel`]
#[derive(Clone, Debug)]
pub struct GetChannelParams {
    /// Channel id.
    pub channel_id: String,
    /// Optional. Attach user data.
    pub user_id: Option<String>
}

/// struct for passing parameters to the method [`get_channel_mapping_options`]
#[derive(Clone, Debug)]
pub struct GetChannelMappingOptionsParams {
    /// Provider id.
    pub provider_id: Option<String>
}

/// struct for passing parameters to the method [`get_default_timer`]
#[derive(Clone, Debug)]
pub struct GetDefaultTimerParams {
    /// Optional. To attach default values based on a program.
    pub program_id: Option<String>
}

/// struct for passing parameters to the method [`get_lineups`]
#[derive(Clone, Debug)]
pub struct GetLineupsParams {
    /// Provider id.
    pub id: Option<String>,
    /// Provider type.
    pub r#type: Option<String>,
    /// Location.
    pub location: Option<String>,
    /// Country.
    pub country: Option<String>
}

/// struct for passing parameters to the method [`get_live_recording_file`]
#[derive(Clone, Debug)]
pub struct GetLiveRecordingFileParams {
    /// Recording id.
    pub recording_id: String
}

/// struct for passing parameters to the method [`get_live_stream_file`]
#[derive(Clone, Debug)]
pub struct GetLiveStreamFileParams {
    /// Stream id.
    pub stream_id: String,
    /// Container type.
    pub container: String
}

/// struct for passing parameters to the method [`get_live_tv_channels`]
#[derive(Clone, Debug)]
pub struct GetLiveTvChannelsParams {
    /// Optional. Filter by channel type.
    pub r#type: Option<String>,
    /// Optional. Filter by user and attach user data.
    pub user_id: Option<String>,
    /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
    pub start_index: Option<i32>,
    /// Optional. Filter for movies.
    pub is_movie: Option<bool>,
    /// Optional. Filter for series.
    pub is_series: Option<bool>,
    /// Optional. Filter for news.
    pub is_news: Option<bool>,
    /// Optional. Filter for kids.
    pub is_kids: Option<bool>,
    /// Optional. Filter for sports.
    pub is_sports: Option<bool>,
    /// Optional. The maximum number of records to return.
    pub limit: Option<i32>,
    /// Optional. Filter by channels that are favorites, or not.
    pub is_favorite: Option<bool>,
    /// Optional. Filter by channels that are liked, or not.
    pub is_liked: Option<bool>,
    /// Optional. Filter by channels that are disliked, or not.
    pub is_disliked: Option<bool>,
    /// Optional. Include image information in output.
    pub enable_images: Option<bool>,
    /// Optional. The max number of images to return, per image type.
    pub image_type_limit: Option<i32>,
    /// \"Optional. The image types to include in the output.
    pub enable_image_types: Option<Vec<models::ImageType>>,
    /// Optional. Specify additional fields of information to return in the output.
    pub fields: Option<Vec<models::ItemFields>>,
    /// Optional. Include user data.
    pub enable_user_data: Option<bool>,
    /// Optional. Key to sort by.
    pub sort_by: Option<Vec<models::ItemSortBy>>,
    /// Optional. Sort order.
    pub sort_order: Option<String>,
    /// Optional. Incorporate favorite and like status into channel sorting.
    pub enable_favorite_sorting: Option<bool>,
    /// Optional. Adds current program info to each channel.
    pub add_current_program: Option<bool>
}

/// struct for passing parameters to the method [`get_live_tv_programs`]
#[derive(Clone, Debug)]
pub struct GetLiveTvProgramsParams {
    /// The channels to return guide information for.
    pub channel_ids: Option<Vec<uuid::Uuid>>,
    /// Optional. Filter by user id.
    pub user_id: Option<String>,
    /// Optional. The minimum premiere start date.
    pub min_start_date: Option<String>,
    /// Optional. Filter by programs that have completed airing, or not.
    pub has_aired: Option<bool>,
    /// Optional. Filter by programs that are currently airing, or not.
    pub is_airing: Option<bool>,
    /// Optional. The maximum premiere start date.
    pub max_start_date: Option<String>,
    /// Optional. The minimum premiere end date.
    pub min_end_date: Option<String>,
    /// Optional. The maximum premiere end date.
    pub max_end_date: Option<String>,
    /// Optional. Filter for movies.
    pub is_movie: Option<bool>,
    /// Optional. Filter for series.
    pub is_series: Option<bool>,
    /// Optional. Filter for news.
    pub is_news: Option<bool>,
    /// Optional. Filter for kids.
    pub is_kids: Option<bool>,
    /// Optional. Filter for sports.
    pub is_sports: Option<bool>,
    /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
    pub start_index: Option<i32>,
    /// Optional. The maximum number of records to return.
    pub limit: Option<i32>,
    /// Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
    pub sort_by: Option<Vec<models::ItemSortBy>>,
    /// Sort Order - Ascending,Descending.
    pub sort_order: Option<Vec<models::SortOrder>>,
    /// The genres to return guide information for.
    pub genres: Option<Vec<String>>,
    /// The genre ids to return guide information for.
    pub genre_ids: Option<Vec<uuid::Uuid>>,
    /// Optional. Include image information in output.
    pub enable_images: Option<bool>,
    /// Optional. The max number of images to return, per image type.
    pub image_type_limit: Option<i32>,
    /// Optional. The image types to include in the output.
    pub enable_image_types: Option<Vec<models::ImageType>>,
    /// Optional. Include user data.
    pub enable_user_data: Option<bool>,
    /// Optional. Filter by series timer id.
    pub series_timer_id: Option<String>,
    /// Optional. Filter by library series id.
    pub library_series_id: Option<String>,
    /// Optional. Specify additional fields of information to return in the output.
    pub fields: Option<Vec<models::ItemFields>>,
    /// Retrieve total record count.
    pub enable_total_record_count: Option<bool>
}

/// struct for passing parameters to the method [`get_program`]
#[derive(Clone, Debug)]
pub struct GetProgramParams {
    /// Program id.
    pub program_id: String,
    /// Optional. Attach user data.
    pub user_id: Option<String>
}

/// struct for passing parameters to the method [`get_programs`]
#[derive(Clone, Debug)]
pub struct GetProgramsParams {
    /// Request body.
    pub get_programs_dto: Option<models::GetProgramsDto>
}

/// struct for passing parameters to the method [`get_recommended_programs`]
#[derive(Clone, Debug)]
pub struct GetRecommendedProgramsParams {
    /// Optional. filter by user id.
    pub user_id: Option<String>,
    /// Optional. The maximum number of records to return.
    pub limit: Option<i32>,
    /// Optional. Filter by programs that are currently airing, or not.
    pub is_airing: Option<bool>,
    /// Optional. Filter by programs that have completed airing, or not.
    pub has_aired: Option<bool>,
    /// Optional. Filter for series.
    pub is_series: Option<bool>,
    /// Optional. Filter for movies.
    pub is_movie: Option<bool>,
    /// Optional. Filter for news.
    pub is_news: Option<bool>,
    /// Optional. Filter for kids.
    pub is_kids: Option<bool>,
    /// Optional. Filter for sports.
    pub is_sports: Option<bool>,
    /// Optional. Include image information in output.
    pub enable_images: Option<bool>,
    /// Optional. The max number of images to return, per image type.
    pub image_type_limit: Option<i32>,
    /// Optional. The image types to include in the output.
    pub enable_image_types: Option<Vec<models::ImageType>>,
    /// The genres to return guide information for.
    pub genre_ids: Option<Vec<uuid::Uuid>>,
    /// Optional. Specify additional fields of information to return in the output.
    pub fields: Option<Vec<models::ItemFields>>,
    /// Optional. include user data.
    pub enable_user_data: Option<bool>,
    /// Retrieve total record count.
    pub enable_total_record_count: Option<bool>
}

/// struct for passing parameters to the method [`get_recording`]
#[derive(Clone, Debug)]
pub struct GetRecordingParams {
    /// Recording id.
    pub recording_id: String,
    /// Optional. Attach user data.
    pub user_id: Option<String>
}

/// struct for passing parameters to the method [`get_recording_folders`]
#[derive(Clone, Debug)]
pub struct GetRecordingFoldersParams {
    /// Optional. Filter by user and attach user data.
    pub user_id: Option<String>
}

/// struct for passing parameters to the method [`get_recording_group`]
#[derive(Clone, Debug)]
pub struct GetRecordingGroupParams {
    /// Group id.
    pub group_id: String
}

/// struct for passing parameters to the method [`get_recording_groups`]
#[derive(Clone, Debug)]
pub struct GetRecordingGroupsParams {
    /// Optional. Filter by user and attach user data.
    pub user_id: Option<String>
}

/// struct for passing parameters to the method [`get_recordings`]
#[derive(Clone, Debug)]
pub struct GetRecordingsParams {
    /// Optional. Filter by channel id.
    pub channel_id: Option<String>,
    /// Optional. Filter by user and attach user data.
    pub user_id: Option<String>,
    /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
    pub start_index: Option<i32>,
    /// Optional. The maximum number of records to return.
    pub limit: Option<i32>,
    /// Optional. Filter by recording status.
    pub status: Option<String>,
    /// Optional. Filter by recordings that are in progress, or not.
    pub is_in_progress: Option<bool>,
    /// Optional. Filter by recordings belonging to a series timer.
    pub series_timer_id: Option<String>,
    /// Optional. Include image information in output.
    pub enable_images: Option<bool>,
    /// Optional. The max number of images to return, per image type.
    pub image_type_limit: Option<i32>,
    /// Optional. The image types to include in the output.
    pub enable_image_types: Option<Vec<models::ImageType>>,
    /// Optional. Specify additional fields of information to return in the output.
    pub fields: Option<Vec<models::ItemFields>>,
    /// Optional. Include user data.
    pub enable_user_data: Option<bool>,
    /// Optional. Filter for movies.
    pub is_movie: Option<bool>,
    /// Optional. Filter for series.
    pub is_series: Option<bool>,
    /// Optional. Filter for kids.
    pub is_kids: Option<bool>,
    /// Optional. Filter for sports.
    pub is_sports: Option<bool>,
    /// Optional. Filter for news.
    pub is_news: Option<bool>,
    /// Optional. Filter for is library item.
    pub is_library_item: Option<bool>,
    /// Optional. Return total record count.
    pub enable_total_record_count: Option<bool>
}

/// struct for passing parameters to the method [`get_recordings_series`]
#[derive(Clone, Debug)]
pub struct GetRecordingsSeriesParams {
    /// Optional. Filter by channel id.
    pub channel_id: Option<String>,
    /// Optional. Filter by user and attach user data.
    pub user_id: Option<String>,
    /// Optional. Filter by recording group.
    pub group_id: Option<String>,
    /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
    pub start_index: Option<i32>,
    /// Optional. The maximum number of records to return.
    pub limit: Option<i32>,
    /// Optional. Filter by recording status.
    pub status: Option<String>,
    /// Optional. Filter by recordings that are in progress, or not.
    pub is_in_progress: Option<bool>,
    /// Optional. Filter by recordings belonging to a series timer.
    pub series_timer_id: Option<String>,
    /// Optional. Include image information in output.
    pub enable_images: Option<bool>,
    /// Optional. The max number of images to return, per image type.
    pub image_type_limit: Option<i32>,
    /// Optional. The image types to include in the output.
    pub enable_image_types: Option<Vec<models::ImageType>>,
    /// Optional. Specify additional fields of information to return in the output.
    pub fields: Option<Vec<models::ItemFields>>,
    /// Optional. Include user data.
    pub enable_user_data: Option<bool>,
    /// Optional. Return total record count.
    pub enable_total_record_count: Option<bool>
}

/// struct for passing parameters to the method [`get_series_timer`]
#[derive(Clone, Debug)]
pub struct GetSeriesTimerParams {
    /// Timer id.
    pub timer_id: String
}

/// struct for passing parameters to the method [`get_series_timers`]
#[derive(Clone, Debug)]
pub struct GetSeriesTimersParams {
    /// Optional. Sort by SortName or Priority.
    pub sort_by: Option<String>,
    /// Optional. Sort in Ascending or Descending order.
    pub sort_order: Option<String>
}

/// struct for passing parameters to the method [`get_timer`]
#[derive(Clone, Debug)]
pub struct GetTimerParams {
    /// Timer id.
    pub timer_id: String
}

/// struct for passing parameters to the method [`get_timers`]
#[derive(Clone, Debug)]
pub struct GetTimersParams {
    /// Optional. Filter by channel id.
    pub channel_id: Option<String>,
    /// Optional. Filter by timers belonging to a series timer.
    pub series_timer_id: Option<String>,
    /// Optional. Filter by timers that are active.
    pub is_active: Option<bool>,
    /// Optional. Filter by timers that are scheduled.
    pub is_scheduled: Option<bool>
}

/// struct for passing parameters to the method [`reset_tuner`]
#[derive(Clone, Debug)]
pub struct ResetTunerParams {
    /// Tuner id.
    pub tuner_id: String
}

/// struct for passing parameters to the method [`set_channel_mapping`]
#[derive(Clone, Debug)]
pub struct SetChannelMappingParams {
    /// The set channel mapping dto.
    pub set_channel_mapping_dto: models::SetChannelMappingDto
}

/// struct for passing parameters to the method [`update_series_timer`]
#[derive(Clone, Debug)]
pub struct UpdateSeriesTimerParams {
    /// Timer id.
    pub timer_id: String,
    /// New series timer info.
    pub series_timer_info_dto: Option<models::SeriesTimerInfoDto>
}

/// struct for passing parameters to the method [`update_timer`]
#[derive(Clone, Debug)]
pub struct UpdateTimerParams {
    /// Timer id.
    pub timer_id: String,
    /// New timer info.
    pub timer_info_dto: Option<models::TimerInfoDto>
}


/// struct for typed successes of method [`add_listing_provider`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddListingProviderSuccess {
    Status200(models::ListingsProviderInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`add_tuner_host`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddTunerHostSuccess {
    Status200(models::TunerHostInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`cancel_series_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelSeriesTimerSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`cancel_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelTimerSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_series_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSeriesTimerSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTimerSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_listing_provider`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteListingProviderSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRecordingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_tuner_host`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTunerHostSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`discover_tuners`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoverTunersSuccess {
    Status200(Vec<models::TunerHostInfo>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`discvover_tuners`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscvoverTunersSuccess {
    Status200(Vec<models::TunerHostInfo>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChannelSuccess {
    Status200(models::BaseItemDto),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_channel_mapping_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChannelMappingOptionsSuccess {
    Status200(models::ChannelMappingOptionsDto),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_default_listing_provider`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDefaultListingProviderSuccess {
    Status200(models::ListingsProviderInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_default_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDefaultTimerSuccess {
    Status200(models::SeriesTimerInfoDto),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_guide_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGuideInfoSuccess {
    Status200(models::GuideInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_lineups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLineupsSuccess {
    Status200(Vec<models::NameIdPair>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_live_recording_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLiveRecordingFileSuccess {
    Status200(std::path::PathBuf),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_live_stream_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLiveStreamFileSuccess {
    Status200(std::path::PathBuf),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_live_tv_channels`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLiveTvChannelsSuccess {
    Status200(models::BaseItemDtoQueryResult),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_live_tv_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLiveTvInfoSuccess {
    Status200(models::LiveTvInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_live_tv_programs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLiveTvProgramsSuccess {
    Status200(models::BaseItemDtoQueryResult),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_program`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProgramSuccess {
    Status200(models::BaseItemDto),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_programs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProgramsSuccess {
    Status200(models::BaseItemDtoQueryResult),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_recommended_programs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecommendedProgramsSuccess {
    Status200(models::BaseItemDtoQueryResult),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordingSuccess {
    Status200(models::BaseItemDto),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_recording_folders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordingFoldersSuccess {
    Status200(models::BaseItemDtoQueryResult),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_recording_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordingGroupSuccess {
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_recording_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordingGroupsSuccess {
    Status200(models::BaseItemDtoQueryResult),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_recordings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordingsSuccess {
    Status200(models::BaseItemDtoQueryResult),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_recordings_series`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordingsSeriesSuccess {
    Status200(models::BaseItemDtoQueryResult),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_schedules_direct_countries`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSchedulesDirectCountriesSuccess {
    Status200(std::path::PathBuf),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_series_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSeriesTimerSuccess {
    Status200(models::SeriesTimerInfoDto),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_series_timers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSeriesTimersSuccess {
    Status200(models::SeriesTimerInfoDtoQueryResult),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimerSuccess {
    Status200(models::TimerInfoDto),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_timers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimersSuccess {
    Status200(models::TimerInfoDtoQueryResult),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_tuner_host_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTunerHostTypesSuccess {
    Status200(Vec<models::NameIdPair>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`reset_tuner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetTunerSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`set_channel_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetChannelMappingSuccess {
    Status200(models::TunerChannelMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_series_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSeriesTimerSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTimerSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_listing_provider`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddListingProviderError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_tuner_host`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddTunerHostError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_series_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelSeriesTimerError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelTimerError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_series_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSeriesTimerError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTimerError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_listing_provider`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteListingProviderError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRecordingError {
    Status404(models::ProblemDetails),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_tuner_host`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTunerHostError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discover_tuners`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoverTunersError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discvover_tuners`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscvoverTunersError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChannelError {
    Status404(models::ProblemDetails),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_channel_mapping_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChannelMappingOptionsError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_default_listing_provider`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDefaultListingProviderError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_default_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDefaultTimerError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_guide_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGuideInfoError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_lineups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLineupsError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_live_recording_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLiveRecordingFileError {
    Status404(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_live_stream_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLiveStreamFileError {
    Status404(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_live_tv_channels`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLiveTvChannelsError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_live_tv_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLiveTvInfoError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_live_tv_programs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLiveTvProgramsError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_program`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProgramError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_programs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProgramsError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recommended_programs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecommendedProgramsError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordingError {
    Status404(models::ProblemDetails),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recording_folders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordingFoldersError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recording_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordingGroupError {
    Status404(models::ProblemDetails),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recording_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordingGroupsError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recordings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordingsError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recordings_series`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordingsSeriesError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_schedules_direct_countries`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSchedulesDirectCountriesError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_series_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSeriesTimerError {
    Status404(models::ProblemDetails),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_series_timers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSeriesTimersError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimerError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_timers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimersError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tuner_host_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTunerHostTypesError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_tuner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetTunerError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_channel_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetChannelMappingError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_series_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSeriesTimerError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_timer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTimerError {
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}


pub async fn add_listing_provider(configuration: &configuration::Configuration, params: AddListingProviderParams) -> Result<ResponseContent<AddListingProviderSuccess>, Error<AddListingProviderError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pw = params.pw;
    let validate_listings = params.validate_listings;
    let validate_login = params.validate_login;
    let listings_provider_info = params.listings_provider_info;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/ListingProviders", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pw {
        local_var_req_builder = local_var_req_builder.query(&[("pw", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = validate_listings {
        local_var_req_builder = local_var_req_builder.query(&[("validateListings", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = validate_login {
        local_var_req_builder = local_var_req_builder.query(&[("validateLogin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&listings_provider_info);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<AddListingProviderSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<AddListingProviderError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn add_tuner_host(configuration: &configuration::Configuration, params: AddTunerHostParams) -> Result<ResponseContent<AddTunerHostSuccess>, Error<AddTunerHostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tuner_host_info = params.tuner_host_info;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/TunerHosts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&tuner_host_info);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<AddTunerHostSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<AddTunerHostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn cancel_series_timer(configuration: &configuration::Configuration, params: CancelSeriesTimerParams) -> Result<ResponseContent<CancelSeriesTimerSuccess>, Error<CancelSeriesTimerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let timer_id = params.timer_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/SeriesTimers/{timerId}", local_var_configuration.base_path, timerId=crate::apis::urlencode(timer_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CancelSeriesTimerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CancelSeriesTimerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn cancel_timer(configuration: &configuration::Configuration, params: CancelTimerParams) -> Result<ResponseContent<CancelTimerSuccess>, Error<CancelTimerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let timer_id = params.timer_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Timers/{timerId}", local_var_configuration.base_path, timerId=crate::apis::urlencode(timer_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CancelTimerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CancelTimerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_series_timer(configuration: &configuration::Configuration, params: CreateSeriesTimerParams) -> Result<ResponseContent<CreateSeriesTimerSuccess>, Error<CreateSeriesTimerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let series_timer_info_dto = params.series_timer_info_dto;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/SeriesTimers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&series_timer_info_dto);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSeriesTimerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSeriesTimerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_timer(configuration: &configuration::Configuration, params: CreateTimerParams) -> Result<ResponseContent<CreateTimerSuccess>, Error<CreateTimerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let timer_info_dto = params.timer_info_dto;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Timers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&timer_info_dto);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateTimerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateTimerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_listing_provider(configuration: &configuration::Configuration, params: DeleteListingProviderParams) -> Result<ResponseContent<DeleteListingProviderSuccess>, Error<DeleteListingProviderError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/ListingProviders", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteListingProviderSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteListingProviderError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_recording(configuration: &configuration::Configuration, params: DeleteRecordingParams) -> Result<ResponseContent<DeleteRecordingSuccess>, Error<DeleteRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let recording_id = params.recording_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Recordings/{recordingId}", local_var_configuration.base_path, recordingId=crate::apis::urlencode(recording_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_tuner_host(configuration: &configuration::Configuration, params: DeleteTunerHostParams) -> Result<ResponseContent<DeleteTunerHostSuccess>, Error<DeleteTunerHostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/TunerHosts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteTunerHostSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteTunerHostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn discover_tuners(configuration: &configuration::Configuration, params: DiscoverTunersParams) -> Result<ResponseContent<DiscoverTunersSuccess>, Error<DiscoverTunersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let new_devices_only = params.new_devices_only;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Tuners/Discover", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = new_devices_only {
        local_var_req_builder = local_var_req_builder.query(&[("newDevicesOnly", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DiscoverTunersSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DiscoverTunersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn discvover_tuners(configuration: &configuration::Configuration, params: DiscvoverTunersParams) -> Result<ResponseContent<DiscvoverTunersSuccess>, Error<DiscvoverTunersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let new_devices_only = params.new_devices_only;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Tuners/Discvover", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = new_devices_only {
        local_var_req_builder = local_var_req_builder.query(&[("newDevicesOnly", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DiscvoverTunersSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DiscvoverTunersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_channel(configuration: &configuration::Configuration, params: GetChannelParams) -> Result<ResponseContent<GetChannelSuccess>, Error<GetChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let user_id = params.user_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Channels/{channelId}", local_var_configuration.base_path, channelId=crate::apis::urlencode(channel_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = user_id {
        local_var_req_builder = local_var_req_builder.query(&[("userId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_channel_mapping_options(configuration: &configuration::Configuration, params: GetChannelMappingOptionsParams) -> Result<ResponseContent<GetChannelMappingOptionsSuccess>, Error<GetChannelMappingOptionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let provider_id = params.provider_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/ChannelMappingOptions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = provider_id {
        local_var_req_builder = local_var_req_builder.query(&[("providerId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetChannelMappingOptionsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetChannelMappingOptionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_default_listing_provider(configuration: &configuration::Configuration) -> Result<ResponseContent<GetDefaultListingProviderSuccess>, Error<GetDefaultListingProviderError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/ListingProviders/Default", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetDefaultListingProviderSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetDefaultListingProviderError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_default_timer(configuration: &configuration::Configuration, params: GetDefaultTimerParams) -> Result<ResponseContent<GetDefaultTimerSuccess>, Error<GetDefaultTimerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let program_id = params.program_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Timers/Defaults", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = program_id {
        local_var_req_builder = local_var_req_builder.query(&[("programId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetDefaultTimerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetDefaultTimerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_guide_info(configuration: &configuration::Configuration) -> Result<ResponseContent<GetGuideInfoSuccess>, Error<GetGuideInfoError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/GuideInfo", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetGuideInfoSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetGuideInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_lineups(configuration: &configuration::Configuration, params: GetLineupsParams) -> Result<ResponseContent<GetLineupsSuccess>, Error<GetLineupsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let r#type = params.r#type;
    let location = params.location;
    let country = params.country;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/ListingProviders/Lineups", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = r#type {
        local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = country {
        local_var_req_builder = local_var_req_builder.query(&[("country", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetLineupsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetLineupsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_live_recording_file(configuration: &configuration::Configuration, params: GetLiveRecordingFileParams) -> Result<ResponseContent<GetLiveRecordingFileSuccess>, Error<GetLiveRecordingFileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let recording_id = params.recording_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/LiveRecordings/{recordingId}/stream", local_var_configuration.base_path, recordingId=crate::apis::urlencode(recording_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetLiveRecordingFileSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetLiveRecordingFileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_live_stream_file(configuration: &configuration::Configuration, params: GetLiveStreamFileParams) -> Result<ResponseContent<GetLiveStreamFileSuccess>, Error<GetLiveStreamFileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let stream_id = params.stream_id;
    let container = params.container;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/LiveStreamFiles/{streamId}/stream.{container}", local_var_configuration.base_path, streamId=crate::apis::urlencode(stream_id), container=crate::apis::urlencode(container));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetLiveStreamFileSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetLiveStreamFileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_live_tv_channels(configuration: &configuration::Configuration, params: GetLiveTvChannelsParams) -> Result<ResponseContent<GetLiveTvChannelsSuccess>, Error<GetLiveTvChannelsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let r#type = params.r#type;
    let user_id = params.user_id;
    let start_index = params.start_index;
    let is_movie = params.is_movie;
    let is_series = params.is_series;
    let is_news = params.is_news;
    let is_kids = params.is_kids;
    let is_sports = params.is_sports;
    let limit = params.limit;
    let is_favorite = params.is_favorite;
    let is_liked = params.is_liked;
    let is_disliked = params.is_disliked;
    let enable_images = params.enable_images;
    let image_type_limit = params.image_type_limit;
    let enable_image_types = params.enable_image_types;
    let fields = params.fields;
    let enable_user_data = params.enable_user_data;
    let sort_by = params.sort_by;
    let sort_order = params.sort_order;
    let enable_favorite_sorting = params.enable_favorite_sorting;
    let add_current_program = params.add_current_program;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Channels", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = r#type {
        local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_id {
        local_var_req_builder = local_var_req_builder.query(&[("userId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_index {
        local_var_req_builder = local_var_req_builder.query(&[("startIndex", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_movie {
        local_var_req_builder = local_var_req_builder.query(&[("isMovie", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_series {
        local_var_req_builder = local_var_req_builder.query(&[("isSeries", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_news {
        local_var_req_builder = local_var_req_builder.query(&[("isNews", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_kids {
        local_var_req_builder = local_var_req_builder.query(&[("isKids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_sports {
        local_var_req_builder = local_var_req_builder.query(&[("isSports", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_favorite {
        local_var_req_builder = local_var_req_builder.query(&[("isFavorite", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_liked {
        local_var_req_builder = local_var_req_builder.query(&[("isLiked", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_disliked {
        local_var_req_builder = local_var_req_builder.query(&[("isDisliked", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_images {
        local_var_req_builder = local_var_req_builder.query(&[("enableImages", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = image_type_limit {
        local_var_req_builder = local_var_req_builder.query(&[("imageTypeLimit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_image_types {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("enableImageTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("enableImageTypes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("fields".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("fields", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = enable_user_data {
        local_var_req_builder = local_var_req_builder.query(&[("enableUserData", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_by {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("sortBy".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("sortBy", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = sort_order {
        local_var_req_builder = local_var_req_builder.query(&[("sortOrder", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_favorite_sorting {
        local_var_req_builder = local_var_req_builder.query(&[("enableFavoriteSorting", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = add_current_program {
        local_var_req_builder = local_var_req_builder.query(&[("addCurrentProgram", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetLiveTvChannelsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetLiveTvChannelsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_live_tv_info(configuration: &configuration::Configuration) -> Result<ResponseContent<GetLiveTvInfoSuccess>, Error<GetLiveTvInfoError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Info", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetLiveTvInfoSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetLiveTvInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_live_tv_programs(configuration: &configuration::Configuration, params: GetLiveTvProgramsParams) -> Result<ResponseContent<GetLiveTvProgramsSuccess>, Error<GetLiveTvProgramsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_ids = params.channel_ids;
    let user_id = params.user_id;
    let min_start_date = params.min_start_date;
    let has_aired = params.has_aired;
    let is_airing = params.is_airing;
    let max_start_date = params.max_start_date;
    let min_end_date = params.min_end_date;
    let max_end_date = params.max_end_date;
    let is_movie = params.is_movie;
    let is_series = params.is_series;
    let is_news = params.is_news;
    let is_kids = params.is_kids;
    let is_sports = params.is_sports;
    let start_index = params.start_index;
    let limit = params.limit;
    let sort_by = params.sort_by;
    let sort_order = params.sort_order;
    let genres = params.genres;
    let genre_ids = params.genre_ids;
    let enable_images = params.enable_images;
    let image_type_limit = params.image_type_limit;
    let enable_image_types = params.enable_image_types;
    let enable_user_data = params.enable_user_data;
    let series_timer_id = params.series_timer_id;
    let library_series_id = params.library_series_id;
    let fields = params.fields;
    let enable_total_record_count = params.enable_total_record_count;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Programs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = channel_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("channelIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("channelIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = user_id {
        local_var_req_builder = local_var_req_builder.query(&[("userId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_start_date {
        local_var_req_builder = local_var_req_builder.query(&[("minStartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_aired {
        local_var_req_builder = local_var_req_builder.query(&[("hasAired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_airing {
        local_var_req_builder = local_var_req_builder.query(&[("isAiring", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_start_date {
        local_var_req_builder = local_var_req_builder.query(&[("maxStartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_end_date {
        local_var_req_builder = local_var_req_builder.query(&[("minEndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_end_date {
        local_var_req_builder = local_var_req_builder.query(&[("maxEndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_movie {
        local_var_req_builder = local_var_req_builder.query(&[("isMovie", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_series {
        local_var_req_builder = local_var_req_builder.query(&[("isSeries", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_news {
        local_var_req_builder = local_var_req_builder.query(&[("isNews", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_kids {
        local_var_req_builder = local_var_req_builder.query(&[("isKids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_sports {
        local_var_req_builder = local_var_req_builder.query(&[("isSports", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_index {
        local_var_req_builder = local_var_req_builder.query(&[("startIndex", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_by {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("sortBy".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("sortBy", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = sort_order {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("sortOrder".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("sortOrder", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = genres {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("genres".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("genres", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = genre_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("genreIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("genreIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = enable_images {
        local_var_req_builder = local_var_req_builder.query(&[("enableImages", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = image_type_limit {
        local_var_req_builder = local_var_req_builder.query(&[("imageTypeLimit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_image_types {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("enableImageTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("enableImageTypes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = enable_user_data {
        local_var_req_builder = local_var_req_builder.query(&[("enableUserData", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = series_timer_id {
        local_var_req_builder = local_var_req_builder.query(&[("seriesTimerId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = library_series_id {
        local_var_req_builder = local_var_req_builder.query(&[("librarySeriesId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("fields".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("fields", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = enable_total_record_count {
        local_var_req_builder = local_var_req_builder.query(&[("enableTotalRecordCount", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetLiveTvProgramsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetLiveTvProgramsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_program(configuration: &configuration::Configuration, params: GetProgramParams) -> Result<ResponseContent<GetProgramSuccess>, Error<GetProgramError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let program_id = params.program_id;
    let user_id = params.user_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Programs/{programId}", local_var_configuration.base_path, programId=crate::apis::urlencode(program_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = user_id {
        local_var_req_builder = local_var_req_builder.query(&[("userId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetProgramSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetProgramError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_programs(configuration: &configuration::Configuration, params: GetProgramsParams) -> Result<ResponseContent<GetProgramsSuccess>, Error<GetProgramsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let get_programs_dto = params.get_programs_dto;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Programs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&get_programs_dto);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetProgramsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetProgramsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_recommended_programs(configuration: &configuration::Configuration, params: GetRecommendedProgramsParams) -> Result<ResponseContent<GetRecommendedProgramsSuccess>, Error<GetRecommendedProgramsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;
    let limit = params.limit;
    let is_airing = params.is_airing;
    let has_aired = params.has_aired;
    let is_series = params.is_series;
    let is_movie = params.is_movie;
    let is_news = params.is_news;
    let is_kids = params.is_kids;
    let is_sports = params.is_sports;
    let enable_images = params.enable_images;
    let image_type_limit = params.image_type_limit;
    let enable_image_types = params.enable_image_types;
    let genre_ids = params.genre_ids;
    let fields = params.fields;
    let enable_user_data = params.enable_user_data;
    let enable_total_record_count = params.enable_total_record_count;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Programs/Recommended", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = user_id {
        local_var_req_builder = local_var_req_builder.query(&[("userId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_airing {
        local_var_req_builder = local_var_req_builder.query(&[("isAiring", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_aired {
        local_var_req_builder = local_var_req_builder.query(&[("hasAired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_series {
        local_var_req_builder = local_var_req_builder.query(&[("isSeries", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_movie {
        local_var_req_builder = local_var_req_builder.query(&[("isMovie", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_news {
        local_var_req_builder = local_var_req_builder.query(&[("isNews", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_kids {
        local_var_req_builder = local_var_req_builder.query(&[("isKids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_sports {
        local_var_req_builder = local_var_req_builder.query(&[("isSports", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_images {
        local_var_req_builder = local_var_req_builder.query(&[("enableImages", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = image_type_limit {
        local_var_req_builder = local_var_req_builder.query(&[("imageTypeLimit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_image_types {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("enableImageTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("enableImageTypes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = genre_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("genreIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("genreIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("fields".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("fields", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = enable_user_data {
        local_var_req_builder = local_var_req_builder.query(&[("enableUserData", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_total_record_count {
        local_var_req_builder = local_var_req_builder.query(&[("enableTotalRecordCount", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRecommendedProgramsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRecommendedProgramsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_recording(configuration: &configuration::Configuration, params: GetRecordingParams) -> Result<ResponseContent<GetRecordingSuccess>, Error<GetRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let recording_id = params.recording_id;
    let user_id = params.user_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Recordings/{recordingId}", local_var_configuration.base_path, recordingId=crate::apis::urlencode(recording_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = user_id {
        local_var_req_builder = local_var_req_builder.query(&[("userId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_recording_folders(configuration: &configuration::Configuration, params: GetRecordingFoldersParams) -> Result<ResponseContent<GetRecordingFoldersSuccess>, Error<GetRecordingFoldersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Recordings/Folders", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = user_id {
        local_var_req_builder = local_var_req_builder.query(&[("userId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRecordingFoldersSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRecordingFoldersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_recording_group(configuration: &configuration::Configuration, params: GetRecordingGroupParams) -> Result<ResponseContent<GetRecordingGroupSuccess>, Error<GetRecordingGroupError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let group_id = params.group_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Recordings/Groups/{groupId}", local_var_configuration.base_path, groupId=crate::apis::urlencode(group_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRecordingGroupSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRecordingGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_recording_groups(configuration: &configuration::Configuration, params: GetRecordingGroupsParams) -> Result<ResponseContent<GetRecordingGroupsSuccess>, Error<GetRecordingGroupsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Recordings/Groups", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = user_id {
        local_var_req_builder = local_var_req_builder.query(&[("userId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRecordingGroupsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRecordingGroupsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_recordings(configuration: &configuration::Configuration, params: GetRecordingsParams) -> Result<ResponseContent<GetRecordingsSuccess>, Error<GetRecordingsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let user_id = params.user_id;
    let start_index = params.start_index;
    let limit = params.limit;
    let status = params.status;
    let is_in_progress = params.is_in_progress;
    let series_timer_id = params.series_timer_id;
    let enable_images = params.enable_images;
    let image_type_limit = params.image_type_limit;
    let enable_image_types = params.enable_image_types;
    let fields = params.fields;
    let enable_user_data = params.enable_user_data;
    let is_movie = params.is_movie;
    let is_series = params.is_series;
    let is_kids = params.is_kids;
    let is_sports = params.is_sports;
    let is_news = params.is_news;
    let is_library_item = params.is_library_item;
    let enable_total_record_count = params.enable_total_record_count;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Recordings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = channel_id {
        local_var_req_builder = local_var_req_builder.query(&[("channelId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_id {
        local_var_req_builder = local_var_req_builder.query(&[("userId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_index {
        local_var_req_builder = local_var_req_builder.query(&[("startIndex", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_in_progress {
        local_var_req_builder = local_var_req_builder.query(&[("isInProgress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = series_timer_id {
        local_var_req_builder = local_var_req_builder.query(&[("seriesTimerId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_images {
        local_var_req_builder = local_var_req_builder.query(&[("enableImages", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = image_type_limit {
        local_var_req_builder = local_var_req_builder.query(&[("imageTypeLimit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_image_types {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("enableImageTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("enableImageTypes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("fields".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("fields", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = enable_user_data {
        local_var_req_builder = local_var_req_builder.query(&[("enableUserData", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_movie {
        local_var_req_builder = local_var_req_builder.query(&[("isMovie", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_series {
        local_var_req_builder = local_var_req_builder.query(&[("isSeries", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_kids {
        local_var_req_builder = local_var_req_builder.query(&[("isKids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_sports {
        local_var_req_builder = local_var_req_builder.query(&[("isSports", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_news {
        local_var_req_builder = local_var_req_builder.query(&[("isNews", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_library_item {
        local_var_req_builder = local_var_req_builder.query(&[("isLibraryItem", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_total_record_count {
        local_var_req_builder = local_var_req_builder.query(&[("enableTotalRecordCount", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRecordingsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRecordingsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_recordings_series(configuration: &configuration::Configuration, params: GetRecordingsSeriesParams) -> Result<ResponseContent<GetRecordingsSeriesSuccess>, Error<GetRecordingsSeriesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let user_id = params.user_id;
    let group_id = params.group_id;
    let start_index = params.start_index;
    let limit = params.limit;
    let status = params.status;
    let is_in_progress = params.is_in_progress;
    let series_timer_id = params.series_timer_id;
    let enable_images = params.enable_images;
    let image_type_limit = params.image_type_limit;
    let enable_image_types = params.enable_image_types;
    let fields = params.fields;
    let enable_user_data = params.enable_user_data;
    let enable_total_record_count = params.enable_total_record_count;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Recordings/Series", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = channel_id {
        local_var_req_builder = local_var_req_builder.query(&[("channelId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_id {
        local_var_req_builder = local_var_req_builder.query(&[("userId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = group_id {
        local_var_req_builder = local_var_req_builder.query(&[("groupId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_index {
        local_var_req_builder = local_var_req_builder.query(&[("startIndex", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_in_progress {
        local_var_req_builder = local_var_req_builder.query(&[("isInProgress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = series_timer_id {
        local_var_req_builder = local_var_req_builder.query(&[("seriesTimerId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_images {
        local_var_req_builder = local_var_req_builder.query(&[("enableImages", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = image_type_limit {
        local_var_req_builder = local_var_req_builder.query(&[("imageTypeLimit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_image_types {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("enableImageTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("enableImageTypes", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("fields".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("fields", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = enable_user_data {
        local_var_req_builder = local_var_req_builder.query(&[("enableUserData", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_total_record_count {
        local_var_req_builder = local_var_req_builder.query(&[("enableTotalRecordCount", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRecordingsSeriesSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRecordingsSeriesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_schedules_direct_countries(configuration: &configuration::Configuration) -> Result<ResponseContent<GetSchedulesDirectCountriesSuccess>, Error<GetSchedulesDirectCountriesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/ListingProviders/SchedulesDirect/Countries", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetSchedulesDirectCountriesSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetSchedulesDirectCountriesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_series_timer(configuration: &configuration::Configuration, params: GetSeriesTimerParams) -> Result<ResponseContent<GetSeriesTimerSuccess>, Error<GetSeriesTimerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let timer_id = params.timer_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/SeriesTimers/{timerId}", local_var_configuration.base_path, timerId=crate::apis::urlencode(timer_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetSeriesTimerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetSeriesTimerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_series_timers(configuration: &configuration::Configuration, params: GetSeriesTimersParams) -> Result<ResponseContent<GetSeriesTimersSuccess>, Error<GetSeriesTimersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sort_by = params.sort_by;
    let sort_order = params.sort_order;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/SeriesTimers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sort_by {
        local_var_req_builder = local_var_req_builder.query(&[("sortBy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_order {
        local_var_req_builder = local_var_req_builder.query(&[("sortOrder", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetSeriesTimersSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetSeriesTimersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_timer(configuration: &configuration::Configuration, params: GetTimerParams) -> Result<ResponseContent<GetTimerSuccess>, Error<GetTimerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let timer_id = params.timer_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Timers/{timerId}", local_var_configuration.base_path, timerId=crate::apis::urlencode(timer_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetTimerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetTimerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_timers(configuration: &configuration::Configuration, params: GetTimersParams) -> Result<ResponseContent<GetTimersSuccess>, Error<GetTimersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_id = params.channel_id;
    let series_timer_id = params.series_timer_id;
    let is_active = params.is_active;
    let is_scheduled = params.is_scheduled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Timers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = channel_id {
        local_var_req_builder = local_var_req_builder.query(&[("channelId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = series_timer_id {
        local_var_req_builder = local_var_req_builder.query(&[("seriesTimerId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_active {
        local_var_req_builder = local_var_req_builder.query(&[("isActive", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_scheduled {
        local_var_req_builder = local_var_req_builder.query(&[("isScheduled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetTimersSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetTimersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_tuner_host_types(configuration: &configuration::Configuration) -> Result<ResponseContent<GetTunerHostTypesSuccess>, Error<GetTunerHostTypesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/TunerHosts/Types", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetTunerHostTypesSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetTunerHostTypesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn reset_tuner(configuration: &configuration::Configuration, params: ResetTunerParams) -> Result<ResponseContent<ResetTunerSuccess>, Error<ResetTunerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tuner_id = params.tuner_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Tuners/{tunerId}/Reset", local_var_configuration.base_path, tunerId=crate::apis::urlencode(tuner_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ResetTunerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ResetTunerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn set_channel_mapping(configuration: &configuration::Configuration, params: SetChannelMappingParams) -> Result<ResponseContent<SetChannelMappingSuccess>, Error<SetChannelMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let set_channel_mapping_dto = params.set_channel_mapping_dto;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/ChannelMappings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&set_channel_mapping_dto);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<SetChannelMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<SetChannelMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_series_timer(configuration: &configuration::Configuration, params: UpdateSeriesTimerParams) -> Result<ResponseContent<UpdateSeriesTimerSuccess>, Error<UpdateSeriesTimerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let timer_id = params.timer_id;
    let series_timer_info_dto = params.series_timer_info_dto;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/SeriesTimers/{timerId}", local_var_configuration.base_path, timerId=crate::apis::urlencode(timer_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&series_timer_info_dto);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSeriesTimerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSeriesTimerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_timer(configuration: &configuration::Configuration, params: UpdateTimerParams) -> Result<ResponseContent<UpdateTimerSuccess>, Error<UpdateTimerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let timer_id = params.timer_id;
    let timer_info_dto = params.timer_info_dto;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/LiveTv/Timers/{timerId}", local_var_configuration.base_path, timerId=crate::apis::urlencode(timer_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&timer_info_dto);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateTimerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateTimerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

