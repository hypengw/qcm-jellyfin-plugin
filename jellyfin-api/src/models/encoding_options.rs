/*
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.10.6
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// EncodingOptions : Class EncodingOptions.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct EncodingOptions {
    /// Gets or sets the thread count used for encoding.
    #[serde(rename = "EncodingThreadCount", skip_serializing_if = "Option::is_none")]
    pub encoding_thread_count: Option<i32>,
    /// Gets or sets the temporary transcoding path.
    #[serde(rename = "TranscodingTempPath", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub transcoding_temp_path: Option<Option<String>>,
    /// Gets or sets the path to the fallback font.
    #[serde(rename = "FallbackFontPath", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub fallback_font_path: Option<Option<String>>,
    /// Gets or sets a value indicating whether to use the fallback font.
    #[serde(rename = "EnableFallbackFont", skip_serializing_if = "Option::is_none")]
    pub enable_fallback_font: Option<bool>,
    /// Gets or sets a value indicating whether audio VBR is enabled.
    #[serde(rename = "EnableAudioVbr", skip_serializing_if = "Option::is_none")]
    pub enable_audio_vbr: Option<bool>,
    /// Gets or sets the audio boost applied when downmixing audio.
    #[serde(rename = "DownMixAudioBoost", skip_serializing_if = "Option::is_none")]
    pub down_mix_audio_boost: Option<f64>,
    /// Gets or sets the algorithm used for downmixing audio to stereo.
    #[serde(rename = "DownMixStereoAlgorithm", skip_serializing_if = "Option::is_none")]
    pub down_mix_stereo_algorithm: Option<models::DownMixStereoAlgorithms>,
    /// Gets or sets the maximum size of the muxing queue.
    #[serde(rename = "MaxMuxingQueueSize", skip_serializing_if = "Option::is_none")]
    pub max_muxing_queue_size: Option<i32>,
    /// Gets or sets a value indicating whether throttling is enabled.
    #[serde(rename = "EnableThrottling", skip_serializing_if = "Option::is_none")]
    pub enable_throttling: Option<bool>,
    /// Gets or sets the delay after which throttling happens.
    #[serde(rename = "ThrottleDelaySeconds", skip_serializing_if = "Option::is_none")]
    pub throttle_delay_seconds: Option<i32>,
    /// Gets or sets a value indicating whether segment deletion is enabled.
    #[serde(rename = "EnableSegmentDeletion", skip_serializing_if = "Option::is_none")]
    pub enable_segment_deletion: Option<bool>,
    /// Gets or sets seconds for which segments should be kept before being deleted.
    #[serde(rename = "SegmentKeepSeconds", skip_serializing_if = "Option::is_none")]
    pub segment_keep_seconds: Option<i32>,
    /// Gets or sets the hardware acceleration type.
    #[serde(rename = "HardwareAccelerationType", skip_serializing_if = "Option::is_none")]
    pub hardware_acceleration_type: Option<models::HardwareAccelerationType>,
    /// Gets or sets the FFmpeg path as set by the user via the UI.
    #[serde(rename = "EncoderAppPath", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub encoder_app_path: Option<Option<String>>,
    /// Gets or sets the current FFmpeg path being used by the system and displayed on the transcode page.
    #[serde(rename = "EncoderAppPathDisplay", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub encoder_app_path_display: Option<Option<String>>,
    /// Gets or sets the VA-API device.
    #[serde(rename = "VaapiDevice", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub vaapi_device: Option<Option<String>>,
    /// Gets or sets the QSV device.
    #[serde(rename = "QsvDevice", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub qsv_device: Option<Option<String>>,
    /// Gets or sets a value indicating whether tonemapping is enabled.
    #[serde(rename = "EnableTonemapping", skip_serializing_if = "Option::is_none")]
    pub enable_tonemapping: Option<bool>,
    /// Gets or sets a value indicating whether VPP tonemapping is enabled.
    #[serde(rename = "EnableVppTonemapping", skip_serializing_if = "Option::is_none")]
    pub enable_vpp_tonemapping: Option<bool>,
    /// Gets or sets a value indicating whether videotoolbox tonemapping is enabled.
    #[serde(rename = "EnableVideoToolboxTonemapping", skip_serializing_if = "Option::is_none")]
    pub enable_video_toolbox_tonemapping: Option<bool>,
    /// Gets or sets the tone-mapping algorithm.
    #[serde(rename = "TonemappingAlgorithm", skip_serializing_if = "Option::is_none")]
    pub tonemapping_algorithm: Option<models::TonemappingAlgorithm>,
    /// Gets or sets the tone-mapping mode.
    #[serde(rename = "TonemappingMode", skip_serializing_if = "Option::is_none")]
    pub tonemapping_mode: Option<models::TonemappingMode>,
    /// Gets or sets the tone-mapping range.
    #[serde(rename = "TonemappingRange", skip_serializing_if = "Option::is_none")]
    pub tonemapping_range: Option<models::TonemappingRange>,
    /// Gets or sets the tone-mapping desaturation.
    #[serde(rename = "TonemappingDesat", skip_serializing_if = "Option::is_none")]
    pub tonemapping_desat: Option<f64>,
    /// Gets or sets the tone-mapping peak.
    #[serde(rename = "TonemappingPeak", skip_serializing_if = "Option::is_none")]
    pub tonemapping_peak: Option<f64>,
    /// Gets or sets the tone-mapping parameters.
    #[serde(rename = "TonemappingParam", skip_serializing_if = "Option::is_none")]
    pub tonemapping_param: Option<f64>,
    /// Gets or sets the VPP tone-mapping brightness.
    #[serde(rename = "VppTonemappingBrightness", skip_serializing_if = "Option::is_none")]
    pub vpp_tonemapping_brightness: Option<f64>,
    /// Gets or sets the VPP tone-mapping contrast.
    #[serde(rename = "VppTonemappingContrast", skip_serializing_if = "Option::is_none")]
    pub vpp_tonemapping_contrast: Option<f64>,
    /// Gets or sets the H264 CRF.
    #[serde(rename = "H264Crf", skip_serializing_if = "Option::is_none")]
    pub h264_crf: Option<i32>,
    /// Gets or sets the H265 CRF.
    #[serde(rename = "H265Crf", skip_serializing_if = "Option::is_none")]
    pub h265_crf: Option<i32>,
    /// Gets or sets the encoder preset.
    #[serde(rename = "EncoderPreset", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub encoder_preset: Option<Option<models::EncoderPreset>>,
    /// Gets or sets a value indicating whether the framerate is doubled when deinterlacing.
    #[serde(rename = "DeinterlaceDoubleRate", skip_serializing_if = "Option::is_none")]
    pub deinterlace_double_rate: Option<bool>,
    /// Gets or sets the deinterlace method.
    #[serde(rename = "DeinterlaceMethod", skip_serializing_if = "Option::is_none")]
    pub deinterlace_method: Option<models::DeinterlaceMethod>,
    /// Gets or sets a value indicating whether 10bit HEVC decoding is enabled.
    #[serde(rename = "EnableDecodingColorDepth10Hevc", skip_serializing_if = "Option::is_none")]
    pub enable_decoding_color_depth10_hevc: Option<bool>,
    /// Gets or sets a value indicating whether 10bit VP9 decoding is enabled.
    #[serde(rename = "EnableDecodingColorDepth10Vp9", skip_serializing_if = "Option::is_none")]
    pub enable_decoding_color_depth10_vp9: Option<bool>,
    /// Gets or sets a value indicating whether 8/10bit HEVC RExt decoding is enabled.
    #[serde(rename = "EnableDecodingColorDepth10HevcRext", skip_serializing_if = "Option::is_none")]
    pub enable_decoding_color_depth10_hevc_rext: Option<bool>,
    /// Gets or sets a value indicating whether 12bit HEVC RExt decoding is enabled.
    #[serde(rename = "EnableDecodingColorDepth12HevcRext", skip_serializing_if = "Option::is_none")]
    pub enable_decoding_color_depth12_hevc_rext: Option<bool>,
    /// Gets or sets a value indicating whether the enhanced NVDEC is enabled.
    #[serde(rename = "EnableEnhancedNvdecDecoder", skip_serializing_if = "Option::is_none")]
    pub enable_enhanced_nvdec_decoder: Option<bool>,
    /// Gets or sets a value indicating whether the system native hardware decoder should be used.
    #[serde(rename = "PreferSystemNativeHwDecoder", skip_serializing_if = "Option::is_none")]
    pub prefer_system_native_hw_decoder: Option<bool>,
    /// Gets or sets a value indicating whether the Intel H264 low-power hardware encoder should be used.
    #[serde(rename = "EnableIntelLowPowerH264HwEncoder", skip_serializing_if = "Option::is_none")]
    pub enable_intel_low_power_h264_hw_encoder: Option<bool>,
    /// Gets or sets a value indicating whether the Intel HEVC low-power hardware encoder should be used.
    #[serde(rename = "EnableIntelLowPowerHevcHwEncoder", skip_serializing_if = "Option::is_none")]
    pub enable_intel_low_power_hevc_hw_encoder: Option<bool>,
    /// Gets or sets a value indicating whether hardware encoding is enabled.
    #[serde(rename = "EnableHardwareEncoding", skip_serializing_if = "Option::is_none")]
    pub enable_hardware_encoding: Option<bool>,
    /// Gets or sets a value indicating whether HEVC encoding is enabled.
    #[serde(rename = "AllowHevcEncoding", skip_serializing_if = "Option::is_none")]
    pub allow_hevc_encoding: Option<bool>,
    /// Gets or sets a value indicating whether AV1 encoding is enabled.
    #[serde(rename = "AllowAv1Encoding", skip_serializing_if = "Option::is_none")]
    pub allow_av1_encoding: Option<bool>,
    /// Gets or sets a value indicating whether subtitle extraction is enabled.
    #[serde(rename = "EnableSubtitleExtraction", skip_serializing_if = "Option::is_none")]
    pub enable_subtitle_extraction: Option<bool>,
    /// Gets or sets the codecs hardware encoding is used for.
    #[serde(rename = "HardwareDecodingCodecs", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub hardware_decoding_codecs: Option<Option<Vec<String>>>,
    /// Gets or sets the file extensions on-demand metadata based keyframe extraction is enabled for.
    #[serde(rename = "AllowOnDemandMetadataBasedKeyframeExtractionForExtensions", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub allow_on_demand_metadata_based_keyframe_extraction_for_extensions: Option<Option<Vec<String>>>,
}

impl EncodingOptions {
    /// Class EncodingOptions.
    pub fn new() -> EncodingOptions {
        EncodingOptions {
            encoding_thread_count: None,
            transcoding_temp_path: None,
            fallback_font_path: None,
            enable_fallback_font: None,
            enable_audio_vbr: None,
            down_mix_audio_boost: None,
            down_mix_stereo_algorithm: None,
            max_muxing_queue_size: None,
            enable_throttling: None,
            throttle_delay_seconds: None,
            enable_segment_deletion: None,
            segment_keep_seconds: None,
            hardware_acceleration_type: None,
            encoder_app_path: None,
            encoder_app_path_display: None,
            vaapi_device: None,
            qsv_device: None,
            enable_tonemapping: None,
            enable_vpp_tonemapping: None,
            enable_video_toolbox_tonemapping: None,
            tonemapping_algorithm: None,
            tonemapping_mode: None,
            tonemapping_range: None,
            tonemapping_desat: None,
            tonemapping_peak: None,
            tonemapping_param: None,
            vpp_tonemapping_brightness: None,
            vpp_tonemapping_contrast: None,
            h264_crf: None,
            h265_crf: None,
            encoder_preset: None,
            deinterlace_double_rate: None,
            deinterlace_method: None,
            enable_decoding_color_depth10_hevc: None,
            enable_decoding_color_depth10_vp9: None,
            enable_decoding_color_depth10_hevc_rext: None,
            enable_decoding_color_depth12_hevc_rext: None,
            enable_enhanced_nvdec_decoder: None,
            prefer_system_native_hw_decoder: None,
            enable_intel_low_power_h264_hw_encoder: None,
            enable_intel_low_power_hevc_hw_encoder: None,
            enable_hardware_encoding: None,
            allow_hevc_encoding: None,
            allow_av1_encoding: None,
            enable_subtitle_extraction: None,
            hardware_decoding_codecs: None,
            allow_on_demand_metadata_based_keyframe_extraction_for_extensions: None,
        }
    }
}

